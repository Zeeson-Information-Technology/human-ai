export const runtime = "nodejs";
export const dynamic = "force-dynamic";

import { NextRequest, NextResponse } from "next/server";
import dbConnect from "@/lib/db-connect";
import Session from "@/model/session";
import { Job, type JobDoc } from "@/model/job";
import { Types } from "mongoose";
import { z } from "zod";
import { verifyInvite } from "@/lib/invite-token";
import User from "@/model/user";

const CreateSessionSchema = z.object({
  jobCode: z.string().trim().optional(),
  roleName: z.string().trim().optional(),
  language: z.string().trim().min(2).optional(), // make optional; we’ll derive if missing

  // accept either name
  inviteToken: z.string().trim().optional(),
  ivt: z.string().trim().optional(),

  candidate: z.object({
    name: z.string().trim().min(1),
    email: z.string().email(),
    phone: z.string().trim().optional(),
    linkedin: z.string().url().optional(),
    // you can add screener answers here later if needed
  }),

  resume: z
    .object({
      url: z.string().url().optional(),
      publicId: z.string().trim().optional(),
      fileName: z.string().trim().optional(),
    })
    .optional(),
});

export async function POST(req: NextRequest) {
  try {
    await dbConnect();

    const raw = await req.json().catch(() => null);
    const parsed = CreateSessionSchema.safeParse(raw);
    if (!parsed.success) {
      return NextResponse.json(
        { ok: false, error: "Invalid payload", issues: parsed.error.flatten() },
        { status: 400 }
      );
    }

    let {
      jobCode: jobCodeIn,
      roleName,
      language: langIn,
      inviteToken,
      ivt,
      candidate,
      resume,
    } = parsed.data;

    // Normalize inputs
    const emailLc = candidate.email.trim().toLowerCase();
    const token = (inviteToken || ivt || "").trim();

    // If an invite token is present, verify and enforce it
    if (token) {
      const payload = verifyInvite(token);
      if (!payload) {
        return NextResponse.json(
          { ok: false, error: "Invalid invite token" },
          { status: 400 }
        );
      }

      // Enforce invited email
      if (payload.email !== emailLc) {
        return NextResponse.json(
          { ok: false, error: "Use the invited email to apply" },
          { status: 400 }
        );
      }

      // Enforce / derive job code from token
      const codeFromToken = payload.code.toUpperCase();
      if (jobCodeIn && jobCodeIn.toUpperCase() !== codeFromToken) {
        return NextResponse.json(
          { ok: false, error: "Invite token does not match this job" },
          { status: 400 }
        );
      }
      jobCodeIn = codeFromToken;
    }

    // Resolve job by code (if present)
    const jobCodeUp = jobCodeIn ? jobCodeIn.toUpperCase() : undefined;
    const job: JobDoc | null = jobCodeUp
      ? await Job.findOne({ code: jobCodeUp, active: { $ne: false } }).exec()
      : null;

    // Determine language: explicit → job default → "en"
    const language =
      (langIn && langIn.trim()) ||
      (Array.isArray(job?.languages) && job?.languages.length
        ? String(job!.languages[0])
        : "en");

    // Seed initial steps from job.questionsOverride (optional, language-aware)
    let steps: Array<{
      qId: Types.ObjectId;
      qText: string;
      followupHint?: string;
      source?: "admin" | "ai";
    }> = [];

    if (Array.isArray(job?.questionsOverride) && job.questionsOverride.length) {
      const qs = job.questionsOverride
        .filter((q) => !q.lang || q.lang === language)
        .sort((a, b) => (a.order ?? 0) - (b.order ?? 0));

      steps = qs.map((q) => ({
        qId: new Types.ObjectId(), // synthetic qId for overrides
        qText: String(q.text || "").trim(),
        source: "admin",
      }));
    }

    // Create Session (token auto-generated by schema)
    const doc = await Session.create({
      status: "running",
      startedAt: new Date(),

      // Job linkage + snapshots
      jobCode: job?.code || jobCodeUp,
      jobId: job?._id,
      jobTitle: job?.title || undefined,
      company: job?.company || undefined,
      roleName: job?.roleName || roleName || "Candidate",
      language,
      languagesAllowed:
        Array.isArray(job?.languages) && job?.languages.length
          ? job.languages
          : [language],
      jdTextSnapshot: job?.jdText || undefined,
      focusAreasSnapshot: Array.isArray(job?.focusAreas) ? job.focusAreas : [],
      adminFocusNotesSnapshot: job?.adminFocusNotes || undefined,

      // Candidate (persist linkedin if provided)
      candidate: {
        name: candidate.name.trim(),
        email: emailLc,
        phone: candidate.phone || "",
        linkedin: candidate.linkedin || undefined,
        resume: resume
          ? {
              url: resume.url || undefined,
              publicId: resume.publicId || undefined,
            }
          : undefined,
      },

      // Steps
      steps,
      // scorecard will be added at finalize
    });

    // If candidate email matches a user, update their resume
    if (candidate?.email && resume?.url) {
      await User.updateOne(
        { email: candidate.email.toLowerCase() },
        {
          $set: {
            resume: {
              url: resume.url,
              uploadedAt: new Date(),
              fileName: resume.fileName || "",
            },
          },
        }
      );
    }

    return NextResponse.json(
      {
        ok: true,
        id: String(doc._id),
        token: doc.token,
        job: job
          ? { id: String(job._id), code: job.code, title: job.title }
          : undefined,
        steps: steps.length,
        message: steps.length
          ? "Session created with seeded questions."
          : "Session created. No seeded questions; use /append-step with AI.",
      },
      { status: 201 }
    );
  } catch (err) {
    console.error("/api/zuri/sessions POST error", err);
    return NextResponse.json(
      { ok: false, error: "Server error" },
      { status: 500 }
    );
  }
}
